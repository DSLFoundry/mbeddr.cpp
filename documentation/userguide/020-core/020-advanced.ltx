\section{Command Line Generation}

mbeddr C projects can be generated from the command line via \ic{ant} -- and
through \ic{ant}, they can be included in CI servers. To generate the necessary
ant build file (\ic{build.xml}), mark the respective project in the mbeddr/MPS
IDE and select \ic{(Re-)Generate and build file for Project} from the \ic{Code}
menu. This creates two files, both in the project root directory (next to the
\ic{.mpr} file): a \ic{build.xml} and a \ic{build.properties}.

The \ic{build.xml} file contains the invocation of the MPS generator; its
\ic{build} target performs the actual generation. No changes is ever necessary
in this file. 

The \ic{build.properties} contains local settings. You have to specify the MPS
directory (e.g., the \ic{MPS25.app} directory on a \onmac) and a temp directory
where MPS can create some temporary files.

To run the generator, invoke \ic{ant} in the project directory.


\section{Version Control - working with MPS, mbeddr and git}

This section explains how to use git with MPS. It assumes a basic knowledge
of git and the git command line. The section focuses on the integration with
MPS. We will use the git command line for all of those operations that are not
MPS-specific.

We assume the following setup: you work on your local machine with a clone of an
existing git repository. It is connected to one upstream repository by the name
of \ic{origin}.

\subsection{Preliminaries}

\parhead{VCS Granularity} MPS reuses the version control integration from the
IDEA platform. Consequently, the granularity of version control is the file.
This is quite natural for project files and the like, but for MPS models it can
be confusing at the beginning. Keep in mind that each \emph{model}, living in
solutions or languages, is represented as an XML file, so it is these files that
are handled by the version control system.

\parhead{The MPS Merge Driver} MPS comes with a special merge driver for git (as
well as for SVN) that makes sure MPS models are merged correctly. This merge
driver has to be configured in the local git settings. In the MPS version
control menu there is an entry \emph{Install Version Control AddOn}. Make sure
you execute this menu entry before proceeding any further. As a result, your
\ic{.gitconfig} should contain an entry such as this one:

\begin{lstlisting}[language=mbeddr, morekeywords={}]
[merge "mps"]
	name = MPS merge driver
	driver = "\"/Users/markus/.MPS25/config/mps-merger.sh\" %O %A %B %L"
\end{lstlisting}


\parhead{The .gitignore} For all projects, the \ic{.iws} file should be added to
\ic{.gitignore}, since this contains the local configuration of your project and
should not be shared with others.

Regarding the (temporary Java source) files generated by MPS, two approaches are
possible: they can be checked in or not. Not checking them in means that some of
the version control operations get simpler because there is less "stuff" to deal
with. Checking them in has the advantage that no complete rebuild of these files
is necessary after updating your code from the VCS, so this results in a
faster workflow. 

If you decide \emph{not} to check in temporary Java source files, the following
directories and files should be added to the \ic{.gitignore} in your local
repo:

\begin{itemize}
  \item For languages: \ic{source\_gen}, \ic{source\_gen.caches} and 
  \ic{classes\_gen}
  \item For solutions, if those are Java/BaseLanguage solutions, then the same
  applies as for languages. If these are other solutions to which the
  MPS-integrated Java build does not apply, then \ic{source\_gen} and
  \ic{source\_gen.caches} should be added, plus whatever else your own build
  process creates in terms of temporary files.
\end{itemize}

Make sure the \ic{.history} files are \emph{not} added to the \ic{gitignore}!
These are important for MPS-internal refactorings.

\parhead{MPS' caches and Branching} MPS keeps all kinds of project-related data
in various caches. These caches are outside the project directory and are hence
not checked into the VCS. This is good. But it has one problem: If you change
the branch, your source files change, while the caches are still in the
\emph{old} state. This leads to all kinds of problems. So, as a rule, whenever
you change a branch (that is not just trivially different from the one you have
used so far), make sure you select \ic{File -> Invalidate Caches}, restart and
rebuild your project.

Depending on the degree of change, this may also be advisable after pulling from
the remote repository.





\subsection{Committing Your Work}

In git you can always commit locally. Typically, commits will happen quite
often, on a fine grained level. I like to do these from within MPS. The
screenshot below shows a program where I have just added a new variable. This is
highlighted with the green bar in the gutter. Right-Clicking on the green bar allows you to rever
this change to the latest checked in state.

\begin{center} 
  \includegraphics[width=9cm]{figures/core/green.jpg}
\end{center}


In addition you can use the \ic{Changes} view (from the \ic{Window -> Tool
Windows} menu) to look at the set of changed files. In my case
(see figure below) it is basically one \ic{.mps} file (plus two files realted
to writing this document :-)). This \ic{.mps} file contains the test case to
which I have added the new variable.

\begin{center} 
  \includegraphics[width=12cm]{figures/core/changesview.jpg}
\end{center}

To commit your work, you can now select \ic{Version Control -> Commit Changes}.
The resulting dialog, again, shows you all the changes you have made and you can
choose which one to include in your commit. After committing, your \ic{git
status} will look something like this and you are ready to push:

\begin{lstlisting}[language=mbeddr, morekeywords={}]
Markus-Voelters-MacBook:lwes-assembla markus$ git status
# On branch demo
# Your branch is ahead of 'assembla/demo' by 1 commit.
#
nothing to commit (working directory clean)
Markus-Voelters-MacBook-Air:lwes-assembla markus$ 
\end{lstlisting}

\subsection{Pulling and Merging}

Pulling (or merging) from a remote repository or another branch is when you
potentially get merge conflicts. I usually perform all these operations from the
command line. If you run into merge conflicts, they should be resolved from
within MPS. After the pull or merge, the \ic{Changes} view will highlight
conflicting files in red. You can right-click onto it and select the \ic{Git
-> Merge Tool} option. This will bring up a merge tool on the level of the
projectional editor to resolve the conflict. Please take a look at the
screencast at \\ 
\hspace*{10mm} \ic{http://www.youtube.com/watch?v=gc9oCAnUx7I} 
\\ to see this process in action. 

The process described above and in the video works well for MPS model files.
However, you may also get conflicts in project, language or solution files.
These are XML files, but cannot be edited with the projectional editor. Also,
if one of these files has conflicts and contains the \ic{< < < <} and
\ic{> > > >} merge markers, then MPS cannot open these files anymore because
the XML parser stumbles over these merge markers.

I have found the following two approaches to work:

\begin{itemize}
  \item You can either perform merges or pulls while the project is closed
  in MPS. Conflicts in project, language and solution files should then be 
  resolved with an external merge tool such as \emph{WinMerge} before attempting
  to open the project again in MPS.
  \item Alternatively you can merge or pull while the project is open (so the
  XML files are already parsed). You can then identify those conflicing files
  via the \ic{Changes} view and merge them on XML-level with the MPS merge
  tool. After merging a project file, MPS prompts you that the file has been
  changed on disk and suggests to reload it. You should do this.
\end{itemize}

Please also keep in mind my remark about invalidating caches above.

\subsection{A personal Process with git}

Many people have described their way of working with git regarding branching,
rebasing and merging. In principle each of these will work with MPS, when taking
account what has been discussed above. Here is the process I use.

To develop a feature, I create a feature branch with 

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git branch newFeature
git checkout newFeature
\end{lstlisting}

I then immediately push this new branch to the remote repository as a backup,
and to allow other people to contribute to the branch. I use

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git push -u origin newFeature
\end{lstlisting}

Using the \ic{-u} parameter sets up the branch for remote tracking.

I then work locally on the branch, committing changes in a fine-grained way.
I regularly push the branch to the remote repo. In less regular intervals I pull
in the changes from the master branch to make sure I don't diverge too far from
what happens on the master. I use merge for this:

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git checkout master
git pull                   // this makes sure the master is current
git checkout myFeature
git merge master    
\end{lstlisting}

Alternatively you can also use

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git fetch
git checkout myFeature
git merge origin/master    
\end{lstlisting}


This is the time when conflicts occur and have to be handled. In repeat this
process until my feature is finished. I then merge my changes back on the
master:

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git checkout master
git pull                   // this makes sure the master is current
git merge --squash myFeature    
\end{lstlisting}

Notice the \ic{--squash} option. This allows me to "package" all of the commits
that I have created on my local branch into a single commit with a meaningful
comment such as "initial version of myFeature finished".







